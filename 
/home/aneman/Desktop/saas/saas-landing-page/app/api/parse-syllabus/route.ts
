
import { NextResponse } from 'next/server';

interface ParsedSyllabusData {
  course: {
    name: string;
    instructor: string;
    credits: number;
  };
  events: Array<{
    title: string;
    date: string;
    type: string;
    description?: string;
  }>;
  tasks: Array<{
    title: string;
    due: string;
    priority: 'high' | 'medium' | 'low';
    course: string;
    type: string;
  }>;
  grading: {
    components: Array<{ name: string; weight: string }>;
  };
}

export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: "No file uploaded" }, { status: 400 });
    }

    // Check file type and extract text accordingly
    const fileType = file.type;
    let extractedText = "";

    if (fileType === 'application/pdf') {
      extractedText = await extractTextFromPDF(file);
    } else if (fileType === 'application/vnd.openxmlformats-officedocument.presentationml.presentation') {
      extractedText = await extractTextFromPPTX(file);
    } else if (fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
      extractedText = await extractTextFromDOCX(file);
    } else if (fileType.startsWith('image/')) {
      extractedText = await extractTextFromImage(file);
    } else {
      return NextResponse.json({ 
        error: "Unsupported file type. Supported formats: PDF, PPTX, DOCX, JPG, PNG, GIF, BMP, TIFF" 
      }, { status: 400 });
    }

    if (!extractedText || extractedText.trim().length === 0) {
      return NextResponse.json({ error: "Could not extract text from file" }, { status: 400 });
    }

    // Parse with rule-based parser (AI integration temporarily disabled for build compatibility)
    const structuredData = parseSyllabusWithRules(extractedText);

    return NextResponse.json(structuredData);
  } catch (error) {
    console.error('Syllabus parsing error:', error);
    return NextResponse.json({ 
      error: "Failed to parse syllabus",
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

async function extractTextFromPDF(file: File): Promise<string> {
  try {
    // For now, return a placeholder since pdf-parse has import issues
    console.log('PDF parsing temporarily disabled for build compatibility');
    return "PDF text extraction temporarily disabled. Please upload a different file format.";
  } catch (error) {
    console.error('PDF extraction error:', error);
    throw new Error('Failed to extract text from PDF file');
  }
}

async function extractTextFromPPTX(file: File): Promise<string> {
  try {
    // For now, use a simple fallback
    return await extractTextGeneric(file);
  } catch (error) {
    console.error('PPTX extraction error:', error);
    throw new Error('Failed to extract text from PowerPoint file');
  }
}

async function extractTextFromDOCX(file: File): Promise<string> {
  try {
    // For now, use a simple fallback
    return await extractTextGeneric(file);
  } catch (error) {
    console.error('DOCX extraction error:', error);
    throw new Error('Failed to extract text from Word document');
  }
}

async function extractTextFromImage(file: File): Promise<string> {
  try {
    // For now, return a placeholder since tesseract has import issues
    console.log('Image OCR temporarily disabled for build compatibility');
    return "Image text extraction temporarily disabled. Please upload a different file format.";
  } catch (error) {
    console.error('Image OCR error:', error);
    throw new Error('Failed to extract text from image');
  }
}

// Generic text extraction fallback
async function extractTextGeneric(file: File): Promise<string> {
  const arrayBuffer = await file.arrayBuffer();
  const buffer = Buffer.from(arrayBuffer);
  
  // Try to decode as UTF-8 text
  try {
    return buffer.toString('utf-8');
  } catch {
    // If UTF-8 fails, try to extract readable text patterns
    const text = buffer.toString('latin1');
    // Simple pattern matching for text-like content
    const readableText = text.replace(/[^\x20-\x7E\n\r\t]/g, ' ').replace(/\s+/g, ' ').trim();
    return readableText;
  }
}

function parseSyllabusWithRules(text: string): ParsedSyllabusData {
  // Rule-based parsing as fallback
  const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);
  
  // Extract course information
  const courseName = extractCourseName(lines) || "Unknown Course";
  const instructor = extractInstructor(lines) || "Unknown Instructor";
  const credits = extractCredits(lines) || 3;

  // Extract dates and events
  const events = extractEvents(text);
  
  // Generate tasks from events
  const tasks = events.map(event => ({
    title: event.title,
    due: event.date,
    priority: determinePriority(event.type),
    course: courseName,
    type: event.type
  }));

  // Extract grading components
  const grading = extractGrading(text);

  return {
    course: { name: courseName, instructor, credits },
    events,
    tasks,
    grading
  };
}

function extractCourseName(lines: string[]): string | null {
  // Look for course patterns like "CS 101", "MATH 241", etc.
  for (const line of lines) {
    const courseMatch = line.match(/([A-Z]+\s*\d+[A-Z]*)/i);
    if (courseMatch) {
      return courseMatch[1].toUpperCase();
    }
  }
  
  // Look for "Course:" or similar patterns
  for (const line of lines) {
    if (line.toLowerCase().includes('course') && line.includes(':')) {
      return line.split(':')[1].trim();
    }
  }
  
  return null;
}

function extractInstructor(lines: string[]): string | null {
  for (const line of lines) {
    if (line.toLowerCase().includes('instructor') && line.includes(':')) {
      return line.split(':')[1].trim();
    }
    if (line.toLowerCase().includes('professor') && line.includes(':')) {
      return line.split(':')[1].trim();
    }
  }
  return null;
}

function extractCredits(lines: string[]): number | null {
  for (const line of lines) {
    const creditMatch = line.match(/(\d+)\s*credits?/i);
    if (creditMatch) {
      return parseInt(creditMatch[1]);
    }
  }
  return null;
}

function extractEvents(text: string) {
  const events: Array<{ title: string; date: string; type: string; description?: string }> = [];
  
  // Common patterns for dates
  const datePatterns = [
    /(\w+day,?\s+\w+\s+\d{1,2},?\s+\d{4})/gi, // "Monday, October 15, 2024"
    /(\w+\s+\d{1,2},?\s+\d{4})/gi, // "October 15, 2024"
    /(\d{1,2}\/\d{1,2}\/\d{4})/gi, // "10/15/2024"
    /(\d{1,2}-\d{1,2}-\d{4})/gi, // "10-15-2024"
  ];
  
  // Event type keywords
  const eventTypes = {
    exam: ['exam', 'midterm', 'final', 'test'],
    assignment: ['assignment', 'homework', 'hw', 'project', 'paper'],
    quiz: ['quiz', 'pop quiz'],
    reading: ['reading', 'read chapters', 'read'],
    lab: ['lab', 'laboratory'],
    presentation: ['presentation', 'present']
  };
  
  // Find events with dates
  for (const pattern of datePatterns) {
    const matches = text.matchAll(pattern);
    for (const match of matches) {
      const dateText = match[1];
      const context = getContextAroundMatch(text, match.index!, 200);
      
      const eventType = determineEventType(context, eventTypes);
      const title = generateEventTitle(context, eventType);
      
      events.push({
        title,
        date: dateText,
        type: eventType,
        description: context.substring(0, 100) + '...'
      });
    }
  }
  
  return events;
}

function getContextAroundMatch(text: string, index: number, contextLength: number): string {
  const start = Math.max(0, index - contextLength);
  const end = Math.min(text.length, index + contextLength);
  return text.substring(start, end);
}

function determineEventType(context: string, eventTypes: any): string {
  const lowerContext = context.toLowerCase();
  
  for (const [type, keywords] of Object.entries(eventTypes)) {
    for (const keyword of keywords as string[]) {
      if (lowerContext.includes(keyword)) {
        return type.charAt(0).toUpperCase() + type.slice(1);
      }
    }
  }
  return 'Event';
}

function generateEventTitle(context: string, type: string): string {
  const lines = context.split('\n');
  for (const line of lines) {
    const lowerLine = line.toLowerCase();
    if (lowerLine.includes(type.toLowerCase()) && line.length < 100) {
      return line.trim();
    }
  }
  return `${type} Event`;
}

function determinePriority(type: string): 'high' | 'medium' | 'low' {
  const lowerType = type.toLowerCase();
  if (lowerType.includes('exam') || lowerType.includes('final')) return 'high';
  if (lowerType.includes('project') || lowerType.includes('assignment')) return 'medium';
  return 'low';
}

function extractGrading(text: string) {
  const components: Array<{ name: string; weight: string }> = [];
  
  // Look for grading patterns
  const gradingPatterns = [
    /(\w+[^:]*):\s*(\d+)%/gi,
    /(\w+[^,]*),\s*(\d+)%/gi,
  ];
  
  for (const pattern of gradingPatterns) {
    const matches = text.matchAll(pattern);
    for (const match of matches) {
      const name = match[1].trim();
      const weight = match[2] + '%';
      
      // Filter out irrelevant items
      if (name.length > 3 && !name.toLowerCase().includes('total')) {
        components.push({ name, weight });
      }
    }
  }
  
  return { components };
}

